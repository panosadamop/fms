"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applicationSchematic = exports.applicationGenerator = exports.addLintingToApplication = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const linter_1 = require("@nx/linter");
const jest_1 = require("@nx/jest");
const js_1 = require("@nx/js");
const path_1 = require("path");
const init_1 = require("../init/init");
const versions_1 = require("../../utils/versions");
const e2e_project_1 = require("../e2e-project/e2e-project");
const setup_docker_1 = require("../setup-docker/setup-docker");
const lint_project_1 = require("@nx/linter/src/generators/lint-project/lint-project");
const versions_2 = require("@nx/js/src/utils/versions");
function getWebpackBuildConfig(project, options) {
    return {
        executor: `@nx/webpack:webpack`,
        outputs: ['{options.outputPath}'],
        defaultConfiguration: 'production',
        options: {
            target: 'node',
            compiler: 'tsc',
            outputPath: (0, devkit_1.joinPathFragments)('dist', options.rootProject ? options.name : options.appProjectRoot),
            main: (0, devkit_1.joinPathFragments)(project.sourceRoot, 'main' + (options.js ? '.js' : '.ts')),
            tsConfig: (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'tsconfig.app.json'),
            assets: [(0, devkit_1.joinPathFragments)(project.sourceRoot, 'assets')],
            isolatedConfig: true,
            webpackConfig: (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'webpack.config.js'),
        },
        configurations: {
            development: {},
            production: Object.assign({}, (options.docker && { generateLockfile: true })),
        },
    };
}
function getEsBuildConfig(project, options) {
    return {
        executor: '@nx/esbuild:esbuild',
        outputs: ['{options.outputPath}'],
        defaultConfiguration: 'production',
        options: {
            platform: 'node',
            outputPath: (0, devkit_1.joinPathFragments)('dist', options.rootProject ? options.name : options.appProjectRoot),
            // Use CJS for Node apps for widest compatibility.
            format: ['cjs'],
            bundle: false,
            main: (0, devkit_1.joinPathFragments)(project.sourceRoot, 'main' + (options.js ? '.js' : '.ts')),
            tsConfig: (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'tsconfig.app.json'),
            assets: [(0, devkit_1.joinPathFragments)(project.sourceRoot, 'assets')],
            generatePackageJson: true,
            esbuildOptions: {
                sourcemap: true,
                // Generate CJS files as .js so imports can be './foo' rather than './foo.cjs'.
                outExtension: { '.js': '.js' },
            },
        },
        configurations: {
            development: {},
            production: Object.assign(Object.assign({}, (options.docker && { generateLockfile: true })), { esbuildOptions: {
                    sourcemap: false,
                    // Generate CJS files as .js so imports can be './foo' rather than './foo.cjs'.
                    outExtension: { '.js': '.js' },
                } }),
        },
    };
}
function getServeConfig(options) {
    return {
        executor: '@nx/js:node',
        defaultConfiguration: 'development',
        options: {
            buildTarget: `${options.name}:build`,
        },
        configurations: {
            development: {
                buildTarget: `${options.name}:build:development`,
            },
            production: {
                buildTarget: `${options.name}:build:production`,
            },
        },
    };
}
function addProject(tree, options) {
    const project = {
        root: options.appProjectRoot,
        sourceRoot: (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'src'),
        projectType: 'application',
        targets: {},
        tags: options.parsedTags,
    };
    project.targets.build =
        options.bundler === 'esbuild'
            ? getEsBuildConfig(project, options)
            : getWebpackBuildConfig(project, options);
    project.targets.serve = getServeConfig(options);
    (0, devkit_1.addProjectConfiguration)(tree, options.name, project, options.standaloneConfig);
}
function addAppFiles(tree, options) {
    (0, devkit_1.generateFiles)(tree, (0, path_1.join)(__dirname, './files/common'), options.appProjectRoot, Object.assign(Object.assign({}, options), { tmpl: '', name: options.name, root: options.appProjectRoot, offset: (0, devkit_1.offsetFromRoot)(options.appProjectRoot), rootTsConfigPath: (0, js_1.getRelativePathToRootTsConfig)(tree, options.appProjectRoot) }));
    if (options.bundler !== 'webpack') {
        tree.delete((0, devkit_1.joinPathFragments)(options.appProjectRoot, 'webpack.config.js'));
    }
    if (options.framework && options.framework !== 'none') {
        (0, devkit_1.generateFiles)(tree, (0, path_1.join)(__dirname, `./files/${options.framework}`), options.appProjectRoot, Object.assign(Object.assign({}, options), { tmpl: '', name: options.name, root: options.appProjectRoot, offset: (0, devkit_1.offsetFromRoot)(options.appProjectRoot), rootTsConfigPath: (0, js_1.getRelativePathToRootTsConfig)(tree, options.appProjectRoot) }));
    }
    if (options.js) {
        (0, devkit_1.toJS)(tree);
    }
    if (options.pascalCaseFiles) {
        devkit_1.logger.warn('NOTE: --pascalCaseFiles is a noop');
    }
}
function addProxy(tree, options) {
    const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, options.frontendProject);
    if (projectConfig.targets && projectConfig.targets.serve) {
        const pathToProxyFile = `${projectConfig.root}/proxy.conf.json`;
        projectConfig.targets.serve.options = Object.assign(Object.assign({}, projectConfig.targets.serve.options), { proxyConfig: pathToProxyFile });
        if (!tree.exists(pathToProxyFile)) {
            tree.write(pathToProxyFile, JSON.stringify({
                '/api': {
                    target: `http://localhost:${options.port}`,
                    secure: false,
                },
            }, null, 2));
        }
        else {
            //add new entry to existing config
            const proxyFileContent = tree.read(pathToProxyFile).toString();
            const proxyModified = Object.assign(Object.assign({}, JSON.parse(proxyFileContent)), { [`/${options.name}-api`]: {
                    target: `http://localhost:${options.port}`,
                    secure: false,
                } });
            tree.write(pathToProxyFile, JSON.stringify(proxyModified, null, 2));
        }
        (0, devkit_1.updateProjectConfiguration)(tree, options.frontendProject, projectConfig);
    }
}
function addLintingToApplication(tree, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const lintTask = yield (0, linter_1.lintProjectGenerator)(tree, {
            linter: options.linter,
            project: options.name,
            tsConfigPaths: [
                (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'tsconfig.app.json'),
            ],
            eslintFilePatterns: [
                (0, lint_project_1.mapLintPattern)(options.appProjectRoot, options.js ? 'js' : 'ts', options.rootProject),
            ],
            unitTestRunner: options.unitTestRunner,
            skipFormat: true,
            setParserOptionsProject: options.setParserOptionsProject,
            rootProject: options.rootProject,
        });
        return lintTask;
    });
}
exports.addLintingToApplication = addLintingToApplication;
function addProjectDependencies(tree, options) {
    const bundlers = {
        webpack: {
            '@nx/webpack': versions_1.nxVersion,
        },
        esbuild: {
            '@nx/esbuild': versions_1.nxVersion,
            esbuild: versions_2.esbuildVersion,
        },
    };
    const frameworkDependencies = {
        express: {
            express: versions_1.expressVersion,
        },
        koa: {
            koa: versions_1.koaVersion,
        },
        fastify: {
            fastify: versions_1.fastifyVersion,
            'fastify-plugin': versions_1.fastifyPluginVersion,
            '@fastify/autoload': versions_1.fastifyAutoloadVersion,
            '@fastify/sensible': versions_1.fastifySensibleVersion,
        },
    };
    const frameworkDevDependencies = {
        express: {
            '@types/express': versions_1.expressTypingsVersion,
        },
        koa: {
            '@types/koa': versions_1.koaTypingsVersion,
        },
        fastify: {},
    };
    return (0, devkit_1.addDependenciesToPackageJson)(tree, Object.assign({}, frameworkDependencies[options.framework]), Object.assign(Object.assign({}, frameworkDevDependencies[options.framework]), bundlers[options.bundler]));
}
function updateTsConfigOptions(tree, options) {
    (0, devkit_1.updateJson)(tree, `${options.appProjectRoot}/tsconfig.json`, (json) => {
        if (options.rootProject) {
            return Object.assign(Object.assign({ compilerOptions: Object.assign(Object.assign(Object.assign({}, js_1.tsConfigBaseOptions), json.compilerOptions), { esModuleInterop: true }) }, json), { extends: undefined, exclude: ['node_modules', 'tmp'] });
        }
        else {
            return Object.assign(Object.assign({}, json), { compilerOptions: Object.assign(Object.assign({}, json.compilerOptions), { esModuleInterop: true }) });
        }
    });
}
function applicationGenerator(tree, schema) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const options = normalizeOptions(tree, schema);
        const tasks = [];
        if (options.framework === 'nest') {
            const { applicationGenerator } = (0, devkit_1.ensurePackage)('@nx/nest', versions_1.nxVersion);
            return yield applicationGenerator(tree, Object.assign(Object.assign({}, options), { skipFormat: true }));
        }
        const initTask = yield (0, init_1.initGenerator)(tree, Object.assign(Object.assign({}, schema), { skipFormat: true }));
        tasks.push(initTask);
        const installTask = addProjectDependencies(tree, options);
        tasks.push(installTask);
        addAppFiles(tree, options);
        addProject(tree, options);
        updateTsConfigOptions(tree, options);
        if (options.linter === linter_1.Linter.EsLint) {
            const lintTask = yield addLintingToApplication(tree, options);
            tasks.push(lintTask);
        }
        if (options.unitTestRunner === 'jest') {
            const jestTask = yield (0, jest_1.jestProjectGenerator)(tree, Object.assign(Object.assign({}, options), { project: options.name, setupFile: 'none', skipSerializers: true, supportTsx: options.js, testEnvironment: 'node', compiler: 'tsc', skipFormat: true }));
            tasks.push(jestTask);
        }
        else {
            // No need for default spec file if unit testing is not setup.
            tree.delete((0, devkit_1.joinPathFragments)(options.appProjectRoot, 'src/app/app.spec.ts'));
        }
        if (options.e2eTestRunner === 'jest') {
            const e2eTask = yield (0, e2e_project_1.e2eProjectGenerator)(tree, Object.assign(Object.assign({}, options), { projectType: options.framework === 'none' ? 'cli' : 'server', name: options.rootProject ? 'e2e' : `${options.name}-e2e`, project: options.name, port: options.port, isNest: options.isNest, skipFormat: true }));
            tasks.push(e2eTask);
        }
        if (options.js) {
            (0, devkit_1.updateTsConfigsToJs)(tree, { projectRoot: options.appProjectRoot });
        }
        if (options.frontendProject) {
            addProxy(tree, options);
        }
        if (options.docker) {
            const dockerTask = yield (0, setup_docker_1.setupDockerGenerator)(tree, Object.assign(Object.assign({}, options), { project: options.name, skipFormat: true }));
            tasks.push(dockerTask);
        }
        if (!options.skipFormat) {
            yield (0, devkit_1.formatFiles)(tree);
        }
        return (0, devkit_1.runTasksInSerial)(...tasks);
    });
}
exports.applicationGenerator = applicationGenerator;
function normalizeOptions(host, options) {
    var _a, _b, _c, _d, _e, _f;
    const { layoutDirectory, projectDirectory } = (0, devkit_1.extractLayoutDirectory)(options.directory);
    const appsDir = layoutDirectory !== null && layoutDirectory !== void 0 ? layoutDirectory : (0, devkit_1.getWorkspaceLayout)(host).appsDir;
    const appDirectory = projectDirectory
        ? `${(0, devkit_1.names)(projectDirectory).fileName}/${(0, devkit_1.names)(options.name).fileName}`
        : (0, devkit_1.names)(options.name).fileName;
    const appProjectName = appDirectory.replace(new RegExp('/', 'g'), '-');
    const appProjectRoot = options.rootProject
        ? '.'
        : (0, devkit_1.joinPathFragments)(appsDir, appDirectory);
    options.bundler = (_a = options.bundler) !== null && _a !== void 0 ? _a : 'esbuild';
    options.e2eTestRunner = (_b = options.e2eTestRunner) !== null && _b !== void 0 ? _b : 'jest';
    const parsedTags = options.tags
        ? options.tags.split(',').map((s) => s.trim())
        : [];
    return Object.assign(Object.assign({}, options), { name: (0, devkit_1.names)(appProjectName).fileName, frontendProject: options.frontendProject
            ? (0, devkit_1.names)(options.frontendProject).fileName
            : undefined, appProjectRoot,
        parsedTags, linter: (_c = options.linter) !== null && _c !== void 0 ? _c : linter_1.Linter.EsLint, unitTestRunner: (_d = options.unitTestRunner) !== null && _d !== void 0 ? _d : 'jest', rootProject: (_e = options.rootProject) !== null && _e !== void 0 ? _e : false, port: (_f = options.port) !== null && _f !== void 0 ? _f : 3000 });
}
exports.default = applicationGenerator;
exports.applicationSchematic = (0, devkit_1.convertNxGenerator)(applicationGenerator);
