"use strict";
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    viteConfigurationGenerator: function() {
        return viteConfigurationGenerator;
    },
    default: function() {
        return _default;
    },
    configurationSchematic: function() {
        return configurationSchematic;
    }
});
const _devkit = require("@nx/devkit");
const _generatorutils = require("../../utils/generator-utils");
const _init = require("../init/init");
const _vitestgenerator = require("../vitest/vitest-generator");
async function viteConfigurationGenerator(tree, schema) {
    var _schema;
    const tasks = [];
    const { targets , projectType , root  } = (0, _devkit.readProjectConfiguration)(tree, schema.project);
    let buildTargetName = 'build';
    let serveTargetName = 'serve';
    let testTargetName = 'test';
    var _includeLib;
    (_includeLib = (_schema = schema).includeLib) != null ? _includeLib : _schema.includeLib = projectType === 'library';
    /**
   * This is for when we are converting an existing project
   * to use the vite executors.
   */ let projectAlreadyHasViteTargets = {};
    if (!schema.newProject) {
        var _targets_buildTargetName, _targets_buildTargetName_options;
        const userProvidedTargetName = {
            build: schema.buildTarget,
            serve: schema.serveTarget,
            test: schema.testTarget
        };
        const { validFoundTargetName , projectContainsUnsupportedExecutor , userProvidedTargetIsUnsupported , alreadyHasNxViteTargets  } = (0, _generatorutils.findExistingTargetsInProject)(targets, userProvidedTargetName);
        projectAlreadyHasViteTargets = alreadyHasNxViteTargets;
        /**
     * This means that we only found unsupported build targets in that project.
     * The only way that buildTarget is defined, means that it is supported.
     *
     * If the `unsupported` flag was false, it would mean that we did not find
     * a build target at all, so we can create a new one.
     *
     * So we only throw if we found a target, but it is unsupported.
     */ if (!validFoundTargetName.build && projectContainsUnsupportedExecutor) {
            throw new Error(`The project ${schema.project} cannot be converted to use the @nx/vite executors.`);
        }
        if (alreadyHasNxViteTargets.build && (alreadyHasNxViteTargets.serve || projectType === 'library') && alreadyHasNxViteTargets.test) {
            throw new Error(`The project ${schema.project} is already configured to use the @nx/vite executors.
        Please try a different project, or remove the existing targets 
        and re-run this generator to reset the existing Vite Configuration.
        `);
        }
        /**
     * This means that we did not find any supported executors
     * so we don't have any valid target names.
     *
     * However, the executors that we may have found are not in the
     * list of the specifically unsupported executors either.
     *
     * So, we should warn the user about it.
     */ if (!projectContainsUnsupportedExecutor && !validFoundTargetName.build && !validFoundTargetName.serve && !validFoundTargetName.test) {
            await (0, _generatorutils.handleUnknownExecutors)(schema.project);
        }
        /**
     * There is a possibility at this stage that the user has provided
     * targets with unsupported executors.
     * We keep track here of which of the targets that the user provided
     * are unsupported.
     * We do this with the `userProvidedTargetIsUnsupported` object,
     * which contains flags for each target (whether it is supported or not).
     *
     * We also keep track of the targets that we found in the project,
     * through the findExistingTargetsInProject function, which returns
     * targets for build/serve/test that use supported executors, and
     * can be converted to use the vite executors. These are the
     * kept in the validFoundTargetName object.
     */ await (0, _generatorutils.handleUnsupportedUserProvidedTargets)(userProvidedTargetIsUnsupported, userProvidedTargetName, validFoundTargetName);
        var _validFoundTargetName_build;
        /**
     * Once the user is at this stage, then they can go ahead and convert.
     */ buildTargetName = (_validFoundTargetName_build = validFoundTargetName.build) != null ? _validFoundTargetName_build : buildTargetName;
        var _validFoundTargetName_serve;
        serveTargetName = (_validFoundTargetName_serve = validFoundTargetName.serve) != null ? _validFoundTargetName_serve : serveTargetName;
        if (projectType === 'application') {
            (0, _generatorutils.moveAndEditIndexHtml)(tree, schema, buildTargetName);
        }
        (0, _generatorutils.deleteWebpackConfig)(tree, root, targets == null ? void 0 : (_targets_buildTargetName = targets[buildTargetName]) == null ? void 0 : (_targets_buildTargetName_options = _targets_buildTargetName.options) == null ? void 0 : _targets_buildTargetName_options.webpackConfig);
        (0, _generatorutils.editTsConfig)(tree, schema);
    }
    const initTask = await (0, _init.default)(tree, {
        uiFramework: schema.uiFramework,
        includeLib: schema.includeLib,
        compiler: schema.compiler
    });
    tasks.push(initTask);
    if (!projectAlreadyHasViteTargets.build) {
        (0, _generatorutils.addOrChangeBuildTarget)(tree, schema, buildTargetName);
    }
    if (!schema.includeLib) {
        if (!projectAlreadyHasViteTargets.serve) {
            (0, _generatorutils.addOrChangeServeTarget)(tree, schema, serveTargetName);
        }
        if (!projectAlreadyHasViteTargets.preview) {
            (0, _generatorutils.addPreviewTarget)(tree, schema, serveTargetName);
        }
    }
    (0, _generatorutils.createOrEditViteConfig)(tree, schema, false, projectAlreadyHasViteTargets);
    if (schema.includeVitest) {
        const vitestTask = await (0, _vitestgenerator.default)(tree, {
            project: schema.project,
            uiFramework: schema.uiFramework,
            inSourceTests: schema.inSourceTests,
            coverageProvider: 'c8',
            skipViteConfig: true,
            testTarget: testTargetName,
            skipFormat: true
        });
        tasks.push(vitestTask);
    }
    if (!schema.skipFormat) {
        await (0, _devkit.formatFiles)(tree);
    }
    return (0, _devkit.runTasksInSerial)(...tasks);
}
const _default = viteConfigurationGenerator;
const configurationSchematic = (0, _devkit.convertNxGenerator)(viteConfigurationGenerator);

//# sourceMappingURL=configuration.js.map