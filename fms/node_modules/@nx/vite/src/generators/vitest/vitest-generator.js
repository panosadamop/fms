"use strict";
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    vitestGenerator: function() {
        return vitestGenerator;
    },
    default: function() {
        return _default;
    },
    vitestSchematic: function() {
        return vitestSchematic;
    }
});
const _extends = require("@swc/helpers/_/_extends");
const _devkit = require("@nx/devkit");
const _generatorutils = require("../../utils/generator-utils");
const _init = require("../init/init");
const _versions = require("../../utils/versions");
async function vitestGenerator(tree, schema) {
    const tasks = [];
    const { targets , root , projectType  } = (0, _devkit.readProjectConfiguration)(tree, schema.project);
    var _schema_testTarget, _ref;
    let testTarget = (_ref = (_schema_testTarget = schema.testTarget) != null ? _schema_testTarget : (0, _generatorutils.findExistingTargetsInProject)(targets).validFoundTargetName.test) != null ? _ref : 'test';
    (0, _generatorutils.addOrChangeTestTarget)(tree, schema, testTarget);
    const initTask = await (0, _init.default)(tree, {
        uiFramework: schema.uiFramework
    });
    tasks.push(initTask);
    if (!schema.skipViteConfig) {
        (0, _generatorutils.createOrEditViteConfig)(tree, _extends._({}, schema, {
            includeVitest: true,
            includeLib: projectType === 'library'
        }), true);
    }
    createFiles(tree, schema, root);
    updateTsConfig(tree, schema, root);
    const installCoverageProviderTask = (0, _devkit.addDependenciesToPackageJson)(tree, {}, schema.coverageProvider === 'istanbul' ? {
        '@vitest/coverage-istanbul': _versions.vitestCoverageIstanbulVersion
    } : {
        '@vitest/coverage-c8': _versions.vitestCoverageC8Version
    });
    tasks.push(installCoverageProviderTask);
    if (!schema.skipFormat) {
        await (0, _devkit.formatFiles)(tree);
    }
    return (0, _devkit.runTasksInSerial)(...tasks);
}
function updateTsConfig(tree, options, projectRoot) {
    (0, _devkit.updateJson)(tree, (0, _devkit.joinPathFragments)(projectRoot, 'tsconfig.json'), (json)=>{
        var _json_compilerOptions, _json_compilerOptions_types;
        if (json.references && !json.references.some((r)=>r.path === './tsconfig.spec.json')) {
            json.references.push({
                path: './tsconfig.spec.json'
            });
        }
        if (!((_json_compilerOptions = json.compilerOptions) == null ? void 0 : (_json_compilerOptions_types = _json_compilerOptions.types) == null ? void 0 : _json_compilerOptions_types.includes('vitest'))) {
            var _json_compilerOptions1;
            if ((_json_compilerOptions1 = json.compilerOptions) == null ? void 0 : _json_compilerOptions1.types) {
                json.compilerOptions.types.push('vitest');
            } else {
                var _json;
                var _compilerOptions;
                (_compilerOptions = (_json = json).compilerOptions) != null ? _compilerOptions : _json.compilerOptions = {};
                json.compilerOptions.types = [
                    'vitest'
                ];
            }
        }
        return json;
    });
    if (options.inSourceTests) {
        const tsconfigLibPath = (0, _devkit.joinPathFragments)(projectRoot, 'tsconfig.lib.json');
        const tsconfigAppPath = (0, _devkit.joinPathFragments)(projectRoot, 'tsconfig.app.json');
        if (tree.exists(tsconfigLibPath)) {
            (0, _devkit.updateJson)(tree, (0, _devkit.joinPathFragments)(projectRoot, 'tsconfig.lib.json'), (json)=>{
                var _json_compilerOptions;
                var _types;
                ((_types = (_json_compilerOptions = json.compilerOptions).types) != null ? _types : _json_compilerOptions.types = []).push('vitest/importMeta');
                return json;
            });
        } else if (tree.exists(tsconfigAppPath)) {
            (0, _devkit.updateJson)(tree, (0, _devkit.joinPathFragments)(projectRoot, 'tsconfig.app.json'), (json)=>{
                var _json_compilerOptions;
                var _types;
                ((_types = (_json_compilerOptions = json.compilerOptions).types) != null ? _types : _json_compilerOptions.types = []).push('vitest/importMeta');
                return json;
            });
        }
    }
}
function createFiles(tree, options, projectRoot) {
    (0, _devkit.generateFiles)(tree, (0, _devkit.joinPathFragments)(__dirname, 'files'), projectRoot, _extends._({
        tmpl: ''
    }, options, {
        projectRoot,
        offsetFromRoot: (0, _devkit.offsetFromRoot)(projectRoot)
    }));
}
const _default = vitestGenerator;
const vitestSchematic = (0, _devkit.convertNxGenerator)(vitestGenerator);

//# sourceMappingURL=vitest-generator.js.map