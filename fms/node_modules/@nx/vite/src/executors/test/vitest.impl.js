"use strict";
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    vitestExecutor: function() {
        return vitestExecutor;
    },
    default: function() {
        return _default;
    }
});
const _extends = require("@swc/helpers/_/_extends");
const _devkit = require("@nx/devkit");
const _vite = require("vite");
const _path = require("path");
const _fs = require("fs");
const _internal = require("@nx/js/src/internal");
let NxReporter = class NxReporter {
    async *[Symbol.asyncIterator]() {
        do {
            const hasErrors = await this.deferred.promise;
            yield {
                hasErrors
            };
            this.setupDeferred();
        }while (this.watch)
    }
    setupDeferred() {
        let resolve;
        this.deferred = {
            promise: new Promise((res)=>{
                resolve = res;
            }),
            resolve
        };
    }
    onFinished(files, errors) {
        const hasErrors = files.some((f)=>{
            var _f_result;
            return ((_f_result = f.result) == null ? void 0 : _f_result.state) === 'fail';
        }) || (errors == null ? void 0 : errors.length) > 0;
        this.deferred.resolve(hasErrors);
    }
    constructor(watch){
        this.watch = watch;
        this.setupDeferred();
    }
};
async function* vitestExecutor(options, context) {
    const projectRoot = context.projectsConfigurations.projects[context.projectName].root;
    (0, _internal.registerTsConfigPaths)((0, _path.resolve)(projectRoot, 'tsconfig.json'));
    const { startVitest  } = await Function('return import("vitest/node")')();
    const nxReporter = new NxReporter(options.watch);
    const settings = await getSettings(options, context);
    settings.reporters.push(nxReporter);
    const cliFilters = options.testFile ? [
        options.testFile
    ] : [];
    const ctx = await startVitest(options.mode, cliFilters, settings);
    let hasErrors = false;
    const processExit = ()=>{
        ctx.exit();
        if (hasErrors) {
            process.exit(1);
        } else {
            process.exit(0);
        }
    };
    if (options.watch) {
        process.on('SIGINT', processExit);
        process.on('SIGTERM', processExit);
        process.on('exit', processExit);
    }
    for await (const report of nxReporter){
        // vitest sets the exitCode = 1 when code coverage isn't met
        hasErrors = report.hasErrors || process.exitCode && process.exitCode !== 0;
    }
    return {
        success: !hasErrors
    };
}
async function getSettings(options, context) {
    var _resolved_config, _resolved_config1, _resolved_config_test, _resolved_config2, _resolved_config_test1;
    const projectRoot = context.projectGraph.nodes[context.projectName].data.root;
    const offset = (0, _path.relative)(_devkit.workspaceRoot, context.cwd);
    // if reportsDirectory is not provided vitest will remove all files in the project root
    // when coverage is enabled in the vite.config.ts
    const coverage = options.reportsDirectory ? {
        enabled: options.coverage,
        reportsDirectory: options.reportsDirectory,
        provider: 'c8'
    } : {};
    const viteConfigPath = options.config ? (0, _devkit.joinPathFragments)(context.root, options.config) : findViteConfig((0, _devkit.joinPathFragments)(context.root, projectRoot));
    const resolved = await (0, _vite.loadConfigFromFile)({
        mode: options.mode,
        command: 'serve'
    }, viteConfigPath);
    if (!viteConfigPath || !(resolved == null ? void 0 : (_resolved_config = resolved.config) == null ? void 0 : _resolved_config['test'])) {
        var _resolved_path;
        _devkit.logger.warn((0, _devkit.stripIndents)`Unable to load test config from config file ${(_resolved_path = resolved == null ? void 0 : resolved.path) != null ? _resolved_path : viteConfigPath}
Some settings may not be applied as expected.
You can manually set the config in the project, ${context.projectName}, configuration.
      `);
    }
    var _options_reporters, _ref;
    const settings = _extends._({}, options, {
        // when running nx from the project root, the root will get appended to the cwd.
        // creating an invalid path and no tests will be found.
        // instead if we are not at the root, let the cwd be root.
        root: offset === '' ? projectRoot : '',
        reporters: [
            ...(_options_reporters = options.reporters) != null ? _options_reporters : [],
            ...(_ref = resolved == null ? void 0 : (_resolved_config1 = resolved.config) == null ? void 0 : (_resolved_config_test = _resolved_config1['test']) == null ? void 0 : _resolved_config_test.reporters) != null ? _ref : [],
            'default'
        ],
        coverage: _extends._({}, coverage, resolved == null ? void 0 : (_resolved_config2 = resolved.config) == null ? void 0 : (_resolved_config_test1 = _resolved_config2['test']) == null ? void 0 : _resolved_config_test1.coverage)
    });
    return settings;
}
function findViteConfig(projectRootFullPath) {
    const allowsExt = [
        'js',
        'mjs',
        'ts',
        'cjs',
        'mts',
        'cts'
    ];
    for (const ext of allowsExt){
        if ((0, _fs.existsSync)((0, _devkit.joinPathFragments)(projectRootFullPath, `vite.config.${ext}`))) {
            return (0, _devkit.joinPathFragments)(projectRootFullPath, `vite.config.${ext}`);
        }
    }
}
const _default = vitestExecutor;

//# sourceMappingURL=vitest.impl.js.map