"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const dev_server_impl_1 = require("@nx/webpack/src/executors/dev-server/dev-server.impl");
const path_1 = require("path");
const async_iterable_1 = require("@nx/devkit/src/utils/async-iterable");
const chalk = require("chalk");
const wait_for_port_open_1 = require("@nx/web/src/utils/wait-for-port-open");
const find_matching_projects_1 = require("nx/src/utils/find-matching-projects");
const child_process_1 = require("child_process");
function moduleFederationDevServer(options, context) {
    var _a, _b;
    return tslib_1.__asyncGenerator(this, arguments, function* moduleFederationDevServer_1() {
        const currIter = (0, dev_server_impl_1.default)(options, context);
        const p = context.projectsConfigurations.projects[context.projectName];
        const moduleFederationConfigPath = (0, path_1.join)(context.root, p.root, 'module-federation.config.js');
        let moduleFederationConfig;
        try {
            moduleFederationConfig = require(moduleFederationConfigPath);
        }
        catch (_c) {
            throw new Error(`Could not load ${moduleFederationConfigPath}. Was this project generated with "@nx/react:host"?\nSee: https://nx.dev/recipes/module-federation/faster-builds`);
        }
        const remotesToSkip = new Set((0, find_matching_projects_1.findMatchingProjects)((_a = options.skipRemotes) !== null && _a !== void 0 ? _a : [], context.projectGraph.nodes));
        const knownRemotes = ((_b = moduleFederationConfig.remotes) !== null && _b !== void 0 ? _b : []).filter((r) => {
            const validRemote = Array.isArray(r) ? r[0] : r;
            return !remotesToSkip.has(validRemote);
        });
        const remotePorts = knownRemotes.map((r) => context.projectGraph.nodes[r].data.targets['serve'].options.port);
        const devServeApps = !options.devRemotes
            ? []
            : Array.isArray(options.devRemotes)
                ? (0, find_matching_projects_1.findMatchingProjects)(options.devRemotes, context.projectGraph.nodes)
                : (0, find_matching_projects_1.findMatchingProjects)([options.devRemotes], context.projectGraph.nodes);
        devkit_1.logger.info(`NX Starting module federation dev-server for ${chalk.bold(context.projectName)} with ${knownRemotes.length} remotes`);
        const nxBin = require.resolve('nx');
        const devRemoteIters = [];
        let isCollectingStaticRemoteOutput = true;
        for (const app of knownRemotes) {
            const appName = Array.isArray(app) ? app[0] : app;
            if (devServeApps.includes(appName)) {
                devRemoteIters.push(yield tslib_1.__await((0, devkit_1.runExecutor)({
                    project: appName,
                    target: 'serve',
                    configuration: context.configurationName,
                }, {
                    watch: true,
                }, context)));
            }
            else {
                let outWithErr = [];
                const staticProcess = (0, child_process_1.fork)(nxBin, [
                    'run',
                    `${appName}:serve-static${context.configurationName ? `:${context.configurationName}` : ''}`,
                ], {
                    cwd: context.root,
                    stdio: ['ignore', 'pipe', 'pipe', 'ipc'],
                });
                staticProcess.stdout.on('data', (data) => {
                    if (isCollectingStaticRemoteOutput) {
                        outWithErr.push(data.toString());
                    }
                    else {
                        outWithErr = null;
                        staticProcess.stdout.removeAllListeners('data');
                    }
                });
                staticProcess.stderr.on('data', (data) => devkit_1.logger.info(data.toString()));
                staticProcess.on('exit', (code) => {
                    if (code !== 0) {
                        devkit_1.logger.info(outWithErr.join(''));
                        throw new Error(`Remote failed to start. See above for errors.`);
                    }
                });
                process.on('SIGTERM', () => staticProcess.kill('SIGTERM'));
                process.on('exit', () => staticProcess.kill('SIGTERM'));
            }
        }
        return yield tslib_1.__await(yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues((0, async_iterable_1.combineAsyncIterables)(currIter, ...devRemoteIters, (0, async_iterable_1.createAsyncIterable)(({ next, done }) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (remotePorts.length === 0) {
                done();
                return;
            }
            try {
                yield Promise.all(remotePorts.map((port) => 
                // Allow 20 minutes for each remote to start, which is plenty of time but we can tweak it later if needed.
                // Most remotes should start in under 1 minute.
                (0, wait_for_port_open_1.waitForPortOpen)(port, {
                    retries: 480,
                    retryDelay: 2500,
                })));
                isCollectingStaticRemoteOutput = false;
                devkit_1.logger.info(`NX All remotes started, server ready at http://localhost:${options.port}`);
                next({ success: true, baseUrl: `http://localhost:${options.port}` });
            }
            catch (_d) {
                throw new Error(`Timed out waiting for remote to start. Check above for any errors.`);
            }
            finally {
                done();
            }
        })))))));
    });
}
exports.default = moduleFederationDevServer;
